enum CustomerStatus {
    PENDING,
    REJECTED,
    APPROVED
}

enum AddressMode {
    LEGAL,
    DELIVERY
}

enum VerificationDocumentType {
    IB,
    AFIP,
    ID_FRONT,
    ID_BACK
}


enum DeliveryPreference {
    MORNING,
    AFTERNOON,
    NO_PREFERENCE
}

enum CustomerErrorReason {
    PHONE_ALREADY_EXIST
    TOKEN_EXPIRED
    NO_VERIFICATION_EMAIL_PENDING
    NO_VERIFICATION_SMS_PENDING
    NOT_ADDRESS_CUSTOMER
    CANNOT_SET_LEGAL_ADDRESS_AS_PREFERRED
    INVALID_DELIVERY_ADDRESS_COUNT
}


enum SignInFailedReason {
    PHONE_ALREADY_EXIST
    LEGAL_ID_ALREADY_EXIST
    NAME_ALREADY_EXIST
    USERNAME_ALREADY_EXIST
    INVALID_ADDRESS
    INVALID_ADDRESSES
}

input CustomerInput {
    accessToken: String!
}

input VerificationDocumentInput {
    id: ID
    type: VerificationDocumentType
}

input StateInput {
    id: ID
    name: String
}

input Address {
    id: ID
    formatted: String!
    placeId: String!
    addressName: String!
    addressNumber: String!
    city: String!
    postalCode: String!
    state: StateInput!
    lat: Float
    lon: Float
    additionalInfo: String
    preferred: Boolean
    addressType: AddressMode
    enabled: Boolean
}


input AddressTypeInput {
    id: ID
    formatted: String
    placeId: String
    addressName: String
    addressNumber: String
    city: String
    postalCode: String
    state: StateInput
    lat: Float
    lon: Float
    additionalInfo: String
    preferred: Boolean
    addressType: AddressMode
    enabled: Boolean
    geolocation: String
}

input UserCredentialsSignInInput {
    password: String!
    enabled: Boolean!
}



input SignInUserInput {
    id: ID
    username: String!
    firstName: String!
    lastName: String!
    phone: String!
    credentials: UserCredentialsSignInInput!
}

input RatingScoreInput {
    average: Float
    count: Int
    percentage: Float
}

input SignInInput {
    id: ID
    name: String!
    legalId: String!
    linePhone: String
    user: SignInUserInput!
    addresses: [AddressTypeInput]!
    verificationDocuments: [VerificationDocumentInput]
    deliveryPreference: DeliveryPreference!
    country_id: String
}


enum AddressFailedReason {
    ADDRESS_NOT_FOUND
}

type AddressFailed {
    reason: AddressFailedReason
}

union AddressResponse = AddressType | AddressFailed

input AddressInput {
    id: ID
    formatted: String!
    placeId: String!
    addressName: String
    addressNumber: String
    city: String
    postalCode: String
    state: StateInput
    lat: Float!
    lon: Float!
    additionalInfo: String
    preferred: Boolean
    addressType: AddressMode
    enabled: Boolean
    accessToken: String!
    geolocation: String
}

input AddressIdInput {
    address_id : ID!
    accessToken: String!
}


input CustomerUpdateInput {
    phone: String
    username: String
    deliveryPreference: DeliveryPreference
    verificationDocuments: [VerificationDocumentInput]
    accessToken: String!
}

input VerifyEmailInput {
    id: ID!
    token: String!
}

input VerifyPhoneInput {
    token: String!
    accessToken: String!
}

input PreferredAddressInput {
    addressId: ID!
    accessToken: String!
}

type State {
    id: ID
    name: String
}

type AddressType {
    id: ID
    formatted: String!
    placeId: String!
    addressName: String
    addressNumber: String
    city: String
    postalCode: String
    lat: Float!
    lon: Float!
    additionalInfo: String
    preferred: Boolean
    addressType: AddressMode!
    enabled: Boolean!
}

type VerificationDocument {
    id: ID
    type: VerificationDocumentType
}

type RatingScore {
    average: Float
    count: Int
    percentage: Float
}

type Customer {
    id: ID
    name: String
    enabled: Boolean
    legalId: String
    linePhone: String
    customerStatus: CustomerStatus
    user: User
    smsVerification: Boolean
    emailVerification: Boolean
    addresses: [AddressType]
    verificationDocuments: [VerificationDocument]
    deliveryPreference: DeliveryPreference
    rating: RatingScore
    level: Int
    missingDocuments: [String]
    country_id: String
}

type CustomerErrorFailed {
    customerErrorReason : CustomerErrorReason
}

type SignInFailed {
    reason: SignInFailedReason
}