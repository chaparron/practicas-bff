enum CustomerStatus {
    PENDING,
    REJECTED,
    APPROVED
}

enum AddressMode {
    LEGAL,
    DELIVERY
}

enum VerificationDocumentType {
    IB,
    AFIP,
    ID_FRONT,
    ID_BACK
}

enum CustomerErrorReason {
    PHONE_ALREADY_EXIST
    TOKEN_EXPIRED
    NO_VERIFICATION_EMAIL_PENDING
    NO_VERIFICATION_SMS_PENDING
    NOT_ADDRESS_CUSTOMER
    CANNOT_SET_LEGAL_ADDRESS_AS_PREFERRED
    INVALID_DELIVERY_ADDRESS_COUNT
    INVALID_ADDRESSES,
    INVALID_STATE
}


enum SignInFailedReason {
    PHONE_ALREADY_EXIST
    LEGAL_ID_ALREADY_EXIST
    NAME_ALREADY_EXIST
    USERNAME_ALREADY_EXIST
    INVALID_ADDRESS
    INVALID_ADDRESSES
    INVALID_STATE
    INVALID_PREFERRED_ADDRESS
}


enum DeliveryPreference {
    MORNING,
    AFTERNOON,
    NO_PREFERENCE
}

input CustomerInput {
    accessToken: String!
}

input VerificationDocumentInput {
    id: ID
    type: VerificationDocumentType
}

input WorkingDaysInput {
    days: [DayInput]
    hours: [HourRangeInput]
}


input DayInput {
    dayIndex: Int!
    selected: Boolean
}

input HourRangeInput {
    from: String
    to: String
}


input StateInput {
    id: ID
    name: String
}


input AddressTypeInput {
    id: ID
    formatted: String!
    state: StateInput
    lat: Float!
    lon: Float!
    additionalInfo: String
    addressType: AddressMode!
}

input AddressTypeUpsertInput {
    id: ID
    formatted: String!
    state: StateInput
    lat: Float!
    lon: Float!
    additionalInfo: String
    addressType: AddressMode!
    accessToken: String!
}

input UserCredentialsSignInInput {
    password: String!
    enabled: Boolean!
}



input SignInUserInput {
    id: ID
    username: String!
    firstName: String!
    lastName: String!
    phone: String!
    acceptWhatsApp: Boolean
    credentials: UserCredentialsSignInInput!
}

input RatingScoreInput {
    average: Float
    count: Int
    percentage: Float
}

input SignInInput {
    id: ID
    name: String!
    legalId: String!
    linePhone: String
    user: SignInUserInput!
    addresses: [AddressTypeInput]!
    verificationDocuments: [VerificationDocumentInput]!
    workingDays: WorkingDaysInput
    deliveryComment: String
    country_id: String
}

enum AddressFailedReason {
    ADDRESS_NOT_FOUND
}

type AddressFailed {
    reason: AddressFailedReason
}

union AddressResponse = AddressType | AddressFailed


input AddressIdInput {
    address_id : ID!
    accessToken: String!
}


input CustomerUpdateInput {
    phone: String
    username: String
    acceptWhatsApp: Boolean
    workingDays: WorkingDaysInput
    deliveryComment: String
    verificationDocuments: [VerificationDocumentInput]
    accessToken: String!
}

input VerifyEmailInput {
    id: ID!
    token: String!
}

input VerifyPhoneInput {
    token: String!
    accessToken: String!

}

input PreferredAddressInput {
    addressId: ID!
    accessToken: String!

}

type State {
    id: ID
    name: String
}

type AddressType {
    id: ID
    formatted: String!
    lat: Float!
    lon: Float!
    additionalInfo: String
    preferred: Boolean
    addressType: AddressMode
    enabled: Boolean!
    state: State
}

type VerificationDocument {
    id: ID
    type: VerificationDocumentType
}

type RatingScore {
    average: Float
    count: Int
    percentage: Float
}


type CustomerType {
    id: Int
    name: String
}

type Customer {
    id: ID
    name: String
    enabled: Boolean
    legalId: String
    linePhone: String
    customerStatus: CustomerStatus
    user: User
    smsVerification: Boolean
    emailVerification: Boolean
    addresses: [AddressType]
    verificationDocuments: [VerificationDocument]
    deliveryPreference: DeliveryPreference
    workingDays: WorkingDays!
    rating: RatingScore
    level: Int
    missingDocuments: [String]
    country_id: String
    customerType: CustomerType
    hasOrders: Boolean
}

type WorkingDays {
    days: [Day]!
    hours: [HourRange]!
}

type Day {
    dayIndex: Int
    selected: Boolean
}

type HourRange {
    from: String
    to: String
}

type CustomerErrorFailed {
    customerErrorReason : CustomerErrorReason
}

type SignInFailed {
    reason: SignInFailedReason
}